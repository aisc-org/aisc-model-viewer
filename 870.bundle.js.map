{"version":3,"file":"870.bundle.js","mappings":"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","sources":["webpack://aisc-model-viewer/./src/viewer.ts","webpack://aisc-model-viewer/./src/app.ts"],"sourcesContent":["import * as THREE from 'three'\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport GUI from 'lil-gui'\n\nconst colors = {\n    aisc_blue: new THREE.Color('#00558A'),\n    orange:   new THREE.Color('#FF8200'),\n    white:    new THREE.Color('#FFFFFF'),\n    smokey:   new THREE.Color('#58595B'),\n    valley:   new THREE.Color('#00746F'),\n    globe:    new THREE.Color('#006C93'),\n    smokey_x: new THREE.Color('#333333'),\n    gray_1:   new THREE.Color('#F6F6F6'),\n    gray_2:   new THREE.Color('#E0E0E0'),\n    gray_3:   new THREE.Color('#CACACA'),\n    gray_4:   new THREE.Color('#B6B6B6'),\n    black:    new THREE.Color('#000000'),\n}\n\n\ninterface MorphedAttributes {\n    positionAttribute: THREE.Float32BufferAttribute\n    normalAttribute: THREE.Float32BufferAttribute\n    morphedPositionAttribute: THREE.Float32BufferAttribute\n    morphedNormalAttribute: THREE.Float32BufferAttribute\n}\n\n\n/**\n * Use built-in three.js tools to calculate morphed geometry. Not working\n * as of three.js r131 -- computeMorphedAttributes just returns the same\n * values for positionAttribute and morphedPositionAttribute. Unclear what\n * the underlying problem is.\n */\nfunction getMorphedGeometry(mesh: THREE.Mesh) {\n    const attributes = BufferGeometryUtils.computeMorphedAttributes(mesh) as MorphedAttributes\n\n    const morphed = new THREE.BufferGeometry()\n    morphed.setAttribute('position', attributes.morphedPositionAttribute)\n    morphed.setAttribute('normal', attributes.morphedNormalAttribute)\n    morphed.setIndex(mesh.geometry.index)\n\n    morphed.morphTargetsRelative = mesh.geometry.morphTargetsRelative\n\n    return morphed\n}\n\n\n/**\n * Create new geometry from morphed mesh.\n *\n * Workaround in order to be able to update past three.js r131. A bit\n * hacky: only calculates updated positions, assumes that morph targets\n * are relative, and only supports one morph influence at a time. These\n * are fine for the use case of the model viewer, which is only morphing\n * from undeformed to deformed geometry, and not trying to mix them.\n */\nfunction getMorphedGeometry2(mesh: THREE.Mesh, morphIndex: number) {\n    if (mesh.morphTargetInfluences === undefined) {\n        return mesh.geometry.clone();\n    }\n    if (mesh.geometry.attributes.position instanceof THREE.GLBufferAttribute) {\n        throw new Error(\"Geometries using `GLBufferAttribute` are not supported\");\n    }\n\n    const N = mesh.geometry.attributes.position.array.length\n    const morphedData = new Float32Array(N)\n    const influence = mesh.morphTargetInfluences[morphIndex]\n    for (let i = 0; i < N; i++) {\n        let position = mesh.geometry.attributes.position.array[i]\n        let morph = mesh.geometry.morphAttributes.position[morphIndex].array[i]\n        morphedData[i] = position + influence * morph\n    }\n\n    const morphedGeometry = new THREE.BufferGeometry()\n    morphedGeometry.setIndex(mesh.geometry.index)\n    morphedGeometry.attributes.position = new THREE.Float32BufferAttribute(morphedData, 3)\n\n    return morphedGeometry\n}\n\n\ninterface WireframeOptions {\n    useMorphed?: boolean\n    useWireframe?: boolean\n}\n\n\nexport class ModelViewer {\n    container: HTMLElement\n    loader: GLTFLoader\n\n    scene: THREE.Scene\n    camera: THREE.PerspectiveCamera\n    renderer: THREE.WebGLRenderer\n    controls: OrbitControls\n    loadingSpinner?: HTMLDivElement\n    gui?: GUI\n    titleBlock?: TitleBlock\n\n    wireframeColor: THREE.Color = colors.black\n    backgroundColor: THREE.Color = colors.aisc_blue\n\n    // Whether to render edges as lines in the model.\n    renderEdges: Boolean = true\n\n    // Controls whether the EdgesGeometry used for the outline draws the edge.\n    // If the angle between the adjacent normals exceeds the threshold, the edge\n    // is drawn. Use a fairly high threshold angle -- 20 degrees -- so that\n    // edges don't show up on curved surfaces.\n    edgeThresholdAngle: number = 20\n\n    // Observer that watches for window resizes, and updates the canvas size to\n    // match.\n    private resizeObserver: MutationObserver\n\n    constructor() {\n        const draco = new DRACOLoader()\n        draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/')\n        this.loader = new GLTFLoader()\n        this.loader.setDRACOLoader(draco)\n\n        this.scene = new THREE.Scene()\n        this.scene.background = this.backgroundColor\n        this.camera = new THREE.PerspectiveCamera(75)\n        this.addLights()\n        this.scene.add(this.camera)\n\n        this.renderer = new THREE.WebGLRenderer({ antialias: true })\n        this.renderer.setPixelRatio(window.devicePixelRatio)\n        this.renderer.outputColorSpace = THREE.SRGBColorSpace\n\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement)\n        this.controls.addEventListener('change', this.render.bind(this))\n        this.controls.update()\n\n        matchMedia(`resolution: ${window.devicePixelRatio}dppx`).addEventListener('change', this.updatePixelRatio.bind(this))\n\n        const resizeCallback = this.updateCanvasSize.bind(this)\n        this.resizeObserver = new MutationObserver(resizeCallback)\n        window.addEventListener('resize', resizeCallback)\n\n        // Add viewer as global variable for console access\n        ;(window as any).modelViewer = this\n    }\n\n    destroyContent() {\n        this.destroyGUI()\n        this.titleBlock?.destroy()\n        this.titleBlock = undefined\n    }\n\n    attachToContainer(container: HTMLElement) {\n        this.resizeObserver.disconnect()\n        this.container = container\n        this.resizeObserver.observe(this.container, { attributeFilter: ['style'], childList: true })\n        this.updateCanvasSize()\n    }\n\n    setModelAsCurrent(name: string, desc: string, path: string, center = true, maxScale = 25.0, title?: string) {\n        this.clearScene()\n        this.addLoadingSpinner()\n        this.loader.load(path, (gltf) => {\n            const box = new THREE.Box3().setFromObject(gltf.scene)\n            const size = box.getSize(new THREE.Vector3()).length()\n            const theCenter = new THREE.Vector3()\n            if (center) {\n                // Determine the size of the model, and move it to the center of the scene\n                box.getCenter(theCenter)\n                gltf.scene.position.x += (gltf.scene.position.x - theCenter.x)\n                gltf.scene.position.y += (gltf.scene.position.y - theCenter.y)\n                gltf.scene.position.z += (gltf.scene.position.z - theCenter.z)\n            } else {\n                theCenter.copy(gltf.scene.position)\n            }\n\n            this.controls.reset()\n            this.controls.maxDistance = size*10\n            this.camera.near = size / 100\n            this.camera.far = size * 100\n            this.camera.updateProjectionMatrix()\n\n            this.camera.position.copy(theCenter)\n            this.camera.position.x += size / 2.0\n            this.camera.position.y += size / 5.0\n            this.camera.position.z += size / 2.0\n            this.camera.lookAt(theCenter)\n\n            this.scene.add(gltf.scene)\n\n            let morphableMeshes: THREE.Mesh[] = []\n            gltf.scene.traverse(element => {\n                if (element instanceof THREE.Mesh && element.morphTargetInfluences?.length) {\n                    morphableMeshes.push(element)\n                }\n            })\n            if (morphableMeshes.length > 0) {\n                this.updateGUI(morphableMeshes, maxScale)\n            }\n\n            if (this.renderEdges) {\n                this.addWireframeToGroup(gltf.scene, { useMorphed: true })\n            }\n\n            this.controls.update()\n            this.removeLoadingSpinner()\n        })\n        this.updateCanvasSize()\n\n        if (this.titleBlock === undefined) {\n            this.titleBlock = new TitleBlock()\n            this.container.appendChild(this.titleBlock.domElement)\n        }\n        this.titleBlock.update(title ? title : name, desc)\n    }\n\n    addLoadingSpinner() {\n        if (this.loadingSpinner !== undefined) {\n            this.loadingSpinner.style.visibility = 'visible'\n            return\n        }\n\n        this.loadingSpinner = document.createElement('div')\n        this.loadingSpinner.appendChild(document.createElement('div'))\n        this.loadingSpinner.appendChild(document.createElement('div'))\n        this.loadingSpinner.appendChild(document.createElement('div'))\n        this.loadingSpinner.className = 'loading-spinner'\n        this.container.appendChild(this.loadingSpinner)\n    }\n\n    removeLoadingSpinner() {\n        if (this.loadingSpinner === undefined)\n            return\n\n        this.loadingSpinner.style.visibility = 'hidden'\n    }\n\n    addGUI() {\n        this.destroyGUI()\n        this.gui = new GUI({ autoPlace: false })\n\n        let guiContainer = document.getElementById('gui-wrapper') as HTMLDivElement | null\n        if (guiContainer === null) {\n            guiContainer = document.createElement('div')\n            guiContainer.id = 'gui-wrapper'\n            this.container.appendChild(guiContainer)\n        }\n        guiContainer.appendChild(this.gui.domElement)\n\n        return this.gui\n    }\n\n    updateGUI(morphMeshes: THREE.Mesh[], maxScale = 25.0) {\n        const gui = this.gui ? this.gui : this.addGUI()\n        const params = {\n            Scale: 0.5*maxScale,\n        }\n\n        gui.controllers.forEach(controller => {\n            controller.destroy()\n        })\n\n        const updateScale = (scale: number) => {\n            morphMeshes.forEach(mesh => {\n                if (mesh.morphTargetInfluences?.length){\n                    mesh.morphTargetInfluences.forEach((_, index, mti) => {\n                        mti[index] = scale\n                    })\n                    if (this.renderEdges) {\n                        this.updateWireframe(mesh, { useMorphed: true })\n                    }\n                }\n            })\n            this.render()\n        }\n\n        gui.add(params, 'Scale', 0, maxScale, 0.01).onChange(updateScale)\n        updateScale(params.Scale)\n    }\n\n    destroyGUI() {\n        if (this.gui !== undefined) {\n            this.gui.domElement.remove()\n            this.gui.destroy()\n            this.gui = undefined\n        }\n    }\n\n    addLights() {\n        // three.js now uses a \"non-scaled\" lighting intensity, so need to\n        // multiply by pi? Weird.\n        const ambient = new THREE.AmbientLight(0xFFFFFF, 0.35 * Math.PI)\n        const directional = new THREE.DirectionalLight(0xFFFFFF, 0.65 * Math.PI)\n        directional.position.set(1, 1, 0)\n\n        this.camera.add(ambient, directional)\n    }\n\n    addWireframeToGroup(group: THREE.Group, options?: WireframeOptions) {\n        // For each material, turn on polygonOffset. This very slightly\n        // moves the surface to prevent z-fighting with the wireframe. Store\n        // (and check for) materials we've already updated.\n        const updatedMaterials: THREE.Material[] = []\n        const setPolygonOffset = (material: THREE.Material) => {\n            if (!updatedMaterials.includes(material)) {\n                console.log('Updating material...')\n                material.polygonOffset = true\n                material.polygonOffsetFactor = 1\n                material.polygonOffsetUnits = 1\n                material.needsUpdate = true\n                updatedMaterials.push(material)\n            }\n        }\n\n        group.traverse(element => {\n            if (element instanceof THREE.Mesh) {\n                if (element.material instanceof THREE.Material) {\n                    setPolygonOffset(element.material)\n                } else {\n                    element.material.forEach(setPolygonOffset)\n                }\n                // Create the wireframe from the mesh geometry.\n                this.updateWireframe(element, options)\n            }\n        });\n    }\n\n    /**\n     * Remove any existing wireframe(s) from a mesh.\n     *\n     * @param mesh The mesh to remove wireframe(s) from.\n     */\n    removeWireframe(mesh: THREE.Mesh) {\n        mesh.children.forEach(child => {\n            if (child instanceof THREE.LineSegments) {\n                mesh.remove(child)\n            }\n        })\n    }\n\n    /**\n     * Update the wireframe for a given mesh.\n     *\n     * @param mesh The mesh to add a wireframe to.\n     * @param useMorphed If true, use the morphed geometry to create the edges. Buggy. Default: false\n     * @param useWireframe If true, use WireframeGeometry instead of EdgesGeometry.\n     */\n    updateWireframe(mesh: THREE.Mesh, options?: WireframeOptions) {\n        // Remove the previous wireframe(s)\n        this.removeWireframe(mesh)\n\n        const wireMaterial = new THREE.LineBasicMaterial({\n            color: this.wireframeColor,\n            linewidth: 1.5,\n        })\n\n        const geometry = options?.useMorphed\n            ? getMorphedGeometry2(mesh, 0)\n            : mesh.geometry\n\n        const wireGeometry = options?.useWireframe\n            ? new THREE.WireframeGeometry(geometry)\n            : new THREE.EdgesGeometry(geometry, this.edgeThresholdAngle)\n\n        const wireframe = new THREE.LineSegments(wireGeometry, wireMaterial)\n        mesh.add(wireframe)\n    }\n\n    clearScene() {\n        this.scene.traverse(child => {\n            if (child instanceof THREE.Group) {\n                this.scene.remove(child)\n            }\n        })\n    }\n\n    updateCanvasSize() {\n        if (this.container !== undefined) {\n            console.log('Updating canvas size...')\n            this.camera.aspect = this.container.clientWidth / this.container.clientHeight\n            this.camera.updateProjectionMatrix()\n            // Fire twice; fixes issue where scrollbars leave blank edges around\n            // the canvas.\n            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight)\n            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight)\n            this.render()\n        }\n    }\n\n    updatePixelRatio() {\n        this.renderer.setPixelRatio(window.devicePixelRatio)\n    }\n\n    render() {\n        this.renderer.render(this.scene, this.camera)\n    }\n}\n\n\nclass TitleBlock {\n    domElement: HTMLDivElement\n    private nameElement: HTMLHeadElement\n    private descElement: HTMLParagraphElement\n\n    constructor() {\n        this.domElement = document.createElement('div')\n        this.domElement.id = 'model-title'\n\n        this.nameElement = document.createElement('h2')\n        this.nameElement.id = 'model-name'\n        this.descElement = document.createElement('p')\n        this.descElement.id = 'model-desc'\n\n        this.domElement.appendChild(this.nameElement)\n        this.domElement.appendChild(this.descElement)\n    }\n\n    update(name: string, desc: string = \"\") {\n        this.nameElement.innerText = name\n        this.descElement.innerHTML = desc\n    }\n\n    destroy() {\n        this.domElement.remove()\n    }\n}\n","import { ModelViewer } from './viewer'\nimport './app.css'\n\n\nenum DisplayMode {\n    Landscape,\n    Portrait\n}\n\n\nexport class App {\n    groups: SidebarGroup[]\n    contributors: string[] | undefined\n    contentLinkMap: Map<string, SidebarItem>\n    contentScrollState: Map<string, number>\n    contentContainer: HTMLElement\n    currentElement: HTMLElement\n    currentContent: string\n    sidebarIsOpen: Boolean = true\n    contentSizingMode: DisplayMode = DisplayMode.Landscape\n    forceTrailingSlash = true\n\n    // Default HTML displayed when no item selected, or hash doesn't point to an\n    // actual item.\n    defaultHTML = '<p>Select an item from the sidebar.</p>'\n\n    constructor(params: { title: string, groups: SidebarGroup[], contributors?: string[], addGuideLink?: boolean }) {\n        this.groups = params.groups;\n        this.contributors = params.contributors;\n        this.contentLinkMap = new Map<string, SidebarItem>()\n        this.contentScrollState = new Map<string, number>()\n\n        // Set up the viewer\n        this.contentContainer = document.getElementById('content-container') as HTMLDivElement\n        const headerTitle = document.getElementById('header-title') as HTMLHeadingElement\n        headerTitle.innerHTML = params.title\n\n        // Set up the sidebar\n        const sidebar = document.getElementById('sidebar') as HTMLElement\n        params.groups.forEach((group, index) => {\n            // Each group corresponds to a section in the sidebar.\n            let section = document.createElement('section')\n            section.id = 'sidebar.section.' + group.name.replace(/\\s/g, '_')\n\n            // Each section consists of an <h2> header and a list of items.\n            let header = document.createElement('h2')\n            let list = document.createElement('ul')\n            header.innerHTML = group.name\n            section.appendChild(header)\n            section.appendChild(list)\n\n            // If the group has items, append each item to the list.\n            if (group.items != null) {\n                group.items.forEach(item => {\n                    list.appendChild(item.createItem())\n                    this.contentLinkMap[item.linkname] = item\n                })\n            }\n\n            sidebar.appendChild(section)\n            // Sections are separated by <hr>s. But we don't add a rule after\n            // the last group.\n            if (index !== params.groups.length - 1) {\n                sidebar.appendChild(document.createElement('hr'))\n            }\n        })\n\n        // Sidebar footer\n        sidebar.appendChild(document.createElement('hr'))\n        const sidebarFooter = document.createElement('section')\n        sidebarFooter.className = 'sidebar-footer'\n        sidebar.appendChild(sidebarFooter)\n        const sidebarFooterItems = document.createElement('ul')\n        sidebarFooter.appendChild(sidebarFooterItems)\n\n        if (params.addGuideLink || params.addGuideLink === undefined) {\n            sidebarFooterItems.appendChild(this.guideTo2dDrawingsLink())\n        }\n\n        if (this.contributors !== undefined && this.contributors.length !== 0) {\n            const content = this.contributorsContent()\n            const item = new HtmlItem({ name: 'credits', content: content })\n            this.contentLinkMap[item.linkname] = item\n\n            const creditsLink = document.createElement('a')\n            creditsLink.href = './#credits'\n            creditsLink.innerHTML = 'credits'\n            const creditsLinkItem = document.createElement('li')\n            creditsLinkItem.appendChild(creditsLink)\n            sidebarFooterItems.appendChild(creditsLinkItem)\n        }\n\n        // Responsive content sizing\n        // On portrait displays, we want the content to extend under the sidebar\n        // even when its open.\n        window.addEventListener('resize', this.updateDisplayMode.bind(this))\n        this.updateDisplayMode()\n        if (this.contentSizingMode === DisplayMode.Portrait) {\n            this.toggleSidebar()\n        }\n\n        // Toggling of sidebar\n        const sidebarToggle = document.getElementById('sidebar-toggle') as HTMLButtonElement\n        sidebarToggle.onclick = this.toggleSidebar.bind(this)\n\n        // The current content item is specified by the hash. setCurrentContent\n        // handles:\n        // - saving/restoring the scroll state\n        // - calling the 'onclick' method of the activated item\n        //\n        window.addEventListener('hashchange', this.setCurrentContent.bind(this))\n        this.setCurrentContent()\n\n        // Add app as global variable for console access\n        ;(window as any).modelApp = this\n    }\n\n    updateDisplayMode() {\n        if (window.innerWidth < window.innerHeight && this.contentSizingMode === DisplayMode.Landscape) {\n            this.contentSizingMode = DisplayMode.Portrait\n            if (this.sidebarIsOpen) {\n                this.contentContainer.style.width = '100%'\n            }\n        } else if (window.innerWidth > window.innerHeight && this.contentSizingMode === DisplayMode.Portrait) {\n            this.contentSizingMode = DisplayMode.Landscape\n            if (this.sidebarIsOpen) {\n                this.contentContainer.style.width = 'calc(100% - 250px)'\n            }\n        }\n    }\n\n    toggleSidebar() {\n        const sidebar = document.getElementById('sidebar') as HTMLElement\n        if (this.sidebarIsOpen) {\n            sidebar.style.visibility = 'hidden'\n            if (this.contentSizingMode === DisplayMode.Landscape)\n                this.contentContainer.style.width = '100%'\n        } else {\n            sidebar.style.visibility = 'visible'\n            if (this.contentSizingMode === DisplayMode.Landscape)\n                this.contentContainer.style.width = 'calc(100% - 250px)'\n        }\n        this.sidebarIsOpen = !this.sidebarIsOpen\n    }\n\n    setDefaultContent() {\n        const section = document.createElement('section')\n        section.className = 'html-content'\n        section.innerHTML = this.defaultHTML\n        this.setContentElement(section)\n    }\n\n    contributorsContent() {\n        const section = document.createElement('section')\n        section.className = 'html-content'\n\n        const thanks = document.createElement('p')\n        thanks.innerHTML = 'This collection was developed by:'\n        section.appendChild(thanks)\n\n        const contributorList = document.createElement('ul')\n        this.contributors?.forEach(contributor => {\n            const item = document.createElement('li')\n            item.innerHTML = contributor\n            contributorList.appendChild(item)\n        })\n        section.appendChild(contributorList)\n\n        return section.innerHTML\n    }\n\n    guideTo2dDrawingsLink() {\n        return new Link({\n            name: 'guide to 2d drawings',\n            url: '../guide-to-2d-drawings/#Types-of-drawings',\n            openInNewTab: false,\n        }).createItem()\n    }\n\n    setContentElement(content: HTMLElement) {\n        if (this.currentElement != null) {\n            this.contentContainer.removeChild(this.currentElement)\n        }\n        this.currentElement = content\n        this.contentContainer.appendChild(this.currentElement)\n        // Hide sidebar after clicking link if in portrait mode\n        if (this.contentSizingMode === DisplayMode.Portrait && this.sidebarIsOpen) {\n            this.toggleSidebar()\n        }\n    }\n\n    setCurrentContent() {\n        const loc = window.location\n        if (this.forceTrailingSlash && !loc.pathname.endsWith('/')) {\n            window.location.replace(loc.origin + loc.pathname + '/' + loc.hash)\n        }\n\n        const linkname = window.location.hash.substr(1)\n        const currentItem: SidebarItem = this.contentLinkMap[this.currentContent]\n        const cleanup = currentItem ? currentItem.destroyContent : () => { return Promise.resolve() }\n\n        const item: SidebarItem = this.contentLinkMap[linkname]\n        if (linkname in this.contentLinkMap) {\n            cleanup().then(() => {\n                return item.createContent(this.contentContainer)\n            }).then(content => {\n                // Save scroll position\n                if (this.currentElement) {\n                    console.log('Saving', this.currentContent, 'scroll position as', this.contentContainer.scrollTop)\n                    this.contentScrollState[this.currentContent] = this.contentContainer.scrollTop\n                }\n\n                // Set up content element\n                this.setContentElement(content)\n                this.currentContent = linkname\n                console.log(linkname, 'loaded;', 'The current scroll position is', this.contentContainer.scrollTop)\n\n                // Restore scroll position\n                const scrollPosition = this.contentScrollState[linkname]\n                if (scrollPosition) {\n                    console.log('Restoring', linkname, 'to scroll position', scrollPosition)\n                    this.contentContainer.scrollBy(scrollPosition, scrollPosition)\n                    console.log(linkname, 'restored;', 'The current scroll position is', this.contentContainer.scrollTop)\n                }\n            }, error => {\n                if (error instanceof NoContentError) {\n                    /* No content, no problem */\n                } else {\n                    console.error(error)\n                }\n            })\n        } else {\n            this.setDefaultContent()\n        }\n    }\n}\n\n\nclass NoContentError extends Error { }\n\n\nabstract class SidebarItem {\n    name: string\n    linkname: string\n\n    constructor(name: string) {\n        this.name = name\n        this.linkname = name.replace(/\\s/g, '-')\n    }\n\n    /**\n     * Create the list item that will be added to the sidebar.\n     * @returns listitem - the created HTMLLIElement\n     */\n    abstract createItem(): HTMLLIElement\n\n    /**\n     * Create the content element that will be displayed.\n     *\n     * @param contentContainer - the parent HTMLElement, provided by the running\n     *                           App instance.\n     * @returns Promise&lt;HTMLElement&gt; - the created HTMLElement. The App will handle\n     *                           adding this to the page.\n     */\n    createContent(contentContainer: HTMLElement): Promise<HTMLElement> {\n        return Promise.reject(new NoContentError)\n    }\n\n    /**\n     * Perform cleanup before switching to new content.\n     *\n     */\n    destroyContent() {\n        return Promise.resolve()\n    }\n}\n\n\nexport interface SidebarGroup {\n    name: string\n    items?: SidebarItem[]\n}\n\n\nexport class Link extends SidebarItem {\n    url: string\n    openInNewTab?: boolean\n\n    constructor(params: { name: string, url: string, openInNewTab?: boolean }) {\n        super(params.name)\n        this.url = params.url\n        this.openInNewTab = params.openInNewTab\n    }\n\n    createItem(): HTMLLIElement {\n        const listitem = document.createElement('li')\n        const anchor = document.createElement('a')\n        anchor.href = this.url\n        anchor.innerHTML = this.name\n\n        // Open link in new tab/window\n        if (this.openInNewTab) {\n            anchor.target = '_blank'\n            anchor.rel = 'noreferrer noopener'\n        }\n\n        listitem.appendChild(anchor)\n        return listitem\n    }\n}\n\n\nexport class HtmlItem extends SidebarItem {\n    content: string\n    classes = ['html-content']\n\n    constructor(params: { name: string, content: string, classes?: string[] }) {\n        super(params.name)\n        this.content = params.content\n        if (params.classes) {\n            this.classes.push(...params.classes)\n        }\n    }\n\n    async createContent(contentContainer: HTMLElement): Promise<HTMLElement> {\n        const section = document.createElement('section')\n        section.classList.add(...this.classes)\n        section.innerHTML = this.content\n        // If MathJax is already loaded, then we need to tell it to typeset the\n        // page. If it's not finished loading, it'll typeset the page once it\n        // finishes.\n        if ((window as any).MathJax.typesetPromise !== undefined)\n            await (window as any).MathJax.typesetPromise([section])\n        return Promise.resolve(section)\n    }\n\n    createItem(): HTMLLIElement {\n        const listitem = document.createElement('li')\n        const anchor = document.createElement('a')\n        anchor.href = `#${this.linkname}`\n        anchor.innerHTML = this.name\n        listitem.appendChild(anchor)\n        return listitem\n    }\n}\n\n\nexport class Model extends SidebarItem {\n    path: string\n    centerModel?: boolean\n    maxScale?: number\n    desc: string = \"\"\n    title?: string\n    static viewer: ModelViewer\n\n    constructor(params: { name: string, path: string, center?: boolean, maxScale?: number, desc?: string, title?: string }) {\n        super(params.name)\n        this.path = params.path\n        this.centerModel = params.center\n        this.maxScale = params.maxScale\n        if (params.desc) this.desc = params.desc\n        this.title = params.title\n        if (Model.viewer === undefined) {\n            Model.viewer = new ModelViewer()\n        }\n    }\n\n    createContent(contentContainer: HTMLElement): Promise<HTMLCanvasElement> {\n        Model.viewer.attachToContainer(contentContainer)\n        Model.viewer.setModelAsCurrent(this.name, this.desc, this.path, this.centerModel, this.maxScale, this.title)\n        return Promise.resolve(Model.viewer.renderer.domElement)\n    }\n\n    destroyContent() {\n        Model.viewer.destroyContent()\n        return Promise.resolve()\n    }\n\n    createItem() {\n        const listitem = document.createElement('li')\n        const anchor = document.createElement('a')\n        anchor.href = `#${this.linkname}`\n        anchor.innerHTML = this.name\n        listitem.appendChild(anchor)\n        return listitem\n    }\n}\n"],"names":["DisplayMode","App","constructor","params","sidebarIsOpen","contentSizingMode","Landscape","forceTrailingSlash","defaultHTML","this","groups","contributors","contentLinkMap","Map","contentScrollState","contentContainer","document","getElementById","innerHTML","title","sidebar","forEach","group","index","section","createElement","id","name","replace","header","list","appendChild","items","item","createItem","linkname","length","sidebarFooter","className","sidebarFooterItems","addGuideLink","undefined","guideTo2dDrawingsLink","content","contributorsContent","HtmlItem","creditsLink","href","creditsLinkItem","window","addEventListener","updateDisplayMode","bind","Portrait","toggleSidebar","onclick","setCurrentContent","modelApp","innerWidth","innerHeight","style","width","visibility","setDefaultContent","setContentElement","thanks","contributorList","contributor","Link","url","openInNewTab","currentElement","removeChild","loc","location","pathname","endsWith","origin","hash","substr","currentItem","currentContent","cleanup","destroyContent","Promise","resolve","then","createContent","console","log","scrollTop","scrollPosition","scrollBy","error","NoContentError","Error","SidebarItem","reject","super","listitem","anchor","target","rel","classes","push","classList","add","MathJax","typesetPromise"],"sourceRoot":""}